name: Build and Release STM32 (cube-cmake)

on:
  push:
    branches: [main]
    tags:
      - 'v*.*.*'     # tag like v1.2.3 to trigger a Release
  pull_request:

jobs:
  build:
    runs-on: ubuntu-24.04
    permissions:
      contents: write
    env:
      BUILD_TYPE: ${{ startsWith(github.ref, 'refs/tags/v') && 'Release' || 'Debug' }}
      BUILD_DIR: ${{ startsWith(github.ref, 'refs/tags/v') && 'build/release' || 'build/debug' }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get STM32CubeCLT installer
        run: |
          # Move/ensure the installer is at repo root (adjust if it's already there)
          if [ -f "CI_CD_files/st-stm32cubeclt_1.19.0_25876_20250729_1159_amd64.deb_bundle.sh" ]; then
            mv CI_CD_files/st-stm32cubeclt_1.19.0_25876_20250729_1159_amd64.deb_bundle.sh .
          fi
          ls -l st-stm32cubeclt_1.19.0_25876_20250729_1159_amd64.deb_bundle.sh

      - name: Install STM32CubeCLT (cube-cmake)
        run: |
          export DEBIAN_FRONTEND=noninteractive
          apt-get update
          apt-get install -y dpkg expect
          chmod +x st-stm32cubeclt_1.19.0_25876_20250729_1159_amd64.deb_bundle.sh
          expect <<'EOF'
          set timeout -1
          set ::env(LC_ALL) "C"          ;# keep English prompt if locale varies
          spawn ./st-stm32cubeclt_1.19.0_25876_20250729_1159_amd64.deb_bundle.sh --nox11 -- -y
          expect {
            -re {I ACCEPT.*\[N\/y\]}   { send -- "y\r"; exp_continue }
            -re {Please type y to accept.*} { send -- "y\r"; exp_continue }
            -re {Press (Enter|RETURN) to continue} { send -- "\r"; exp_continue }
            eof
          }
          EOF

          for d in /opt/st/stm32cubeclt_1.19.0/*/bin; do
          export PATH="$d:$PATH"
          done


      - name: Verify toolchain
        run: |
          which cmake
          cmake --version
          which arm-none-eabi-gcc
          arm-none-eabi-gcc --version

      - name: Configure (cube-cmake)
        run: |
          cmake -DCMAKE_BUILD_TYPE="$BUILD_TYPE" -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DCMAKE_TOOLCHAIN_FILE=cmake/gcc-arm-none-eabi.cmake -DCMAKE_COMMAND=cmake -S $(pwd) -B "$BUILD_DIR" -G Ninja

      - name: Build (cube-cmake)
        run: cmake --build "$BUILD_DIR" --

      - name: Package firmware (ELF â†’ BIN/HEX/LST/SIZE)
        run: |
          mkdir -p "${BUILD_DIR}/out"
          mapfile -t ELFS < <(find "${BUILD_DIR}" -type f -name '*.elf')
          if [ ${#ELFS[@]} -eq 0 ]; then
            echo "No .elf files found in ${BUILD_DIR}"; exit 1
          fi
          for ELF in "${ELFS[@]}"; do
            base="$(basename "${ELF%.elf}")"
            arm-none-eabi-objcopy -O binary "${ELF}" "${BUILD_DIR}/out/${base}.bin"
            arm-none-eabi-objcopy -O ihex   "${ELF}" "${BUILD_DIR}/out/${base}.hex"
            arm-none-eabi-objdump -h -S "${ELF}" > "${BUILD_DIR}/out/${base}.lst" || true
            arm-none-eabi-size --format=berkeley "${ELF}" > "${BUILD_DIR}/out/${base}.size" || true
            cp "${ELF}" "${BUILD_DIR}/out/${base}.elf"
          done
          ls -lah "${BUILD_DIR}/out"

      - name: Upload build artifacts
        uses: actions/upload-artifact@v4
        with:
          name: firmware-${{ env.BUILD_TYPE }}
          path: ${{ env.BUILD_DIR }}/out/*

      - name: Create GitHub Release (on tag)
        if: startsWith(github.ref, 'refs/tags/v')
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.ref_name }}
          name: Firmware ${{ github.ref_name }}
          files: |
            ${{ env.BUILD_DIR }}/out/*.bin
            ${{ env.BUILD_DIR }}/out/*.hex
            ${{ env.BUILD_DIR }}/out/*.elf
            ${{ env.BUILD_DIR }}/out/*.lst
            ${{ env.BUILD_DIR }}/out/*.size
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
